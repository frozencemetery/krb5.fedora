From 9a3a64665819a0e1ee82953bf879f57d6f433358 Mon Sep 17 00:00:00 2001
From: Nathaniel McCallum <npmccallum@redhat.com>
Date: Fri, 30 Sep 2016 10:03:33 -0400
Subject: [PATCH] Properly handle EOF condition on libkrad sockets

In the previous code, when the remote peer performed an orderly shutdown
on the socket, libkrad would enter a state in which all future requests
timed out.  Instead, if the peer shuts down its socket, we need to
attempt to reopen it.

ticket: 8504 (new)
target_version: 1.14-next
tags: pullup

(cherry picked from commit 248497427d5a45225817b6c22e9224e8ad969872)
---
 src/lib/krad/remote.c | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/src/lib/krad/remote.c b/src/lib/krad/remote.c
index df3de3a..68cd16f 100644
--- a/src/lib/krad/remote.c
+++ b/src/lib/krad/remote.c
@@ -329,16 +329,15 @@ on_io_read(krad_remote *rr)
     /* Read the packet. */
     i = recv(verto_get_fd(rr->io), rr->buffer.data + rr->buffer.length,
              pktlen, 0);
-    if (i < 0) {
-        /* Should we try again? */
-        if (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR)
-            return;
 
-        /* The socket is unrecoverable. */
+    /* On these errors, try again. */
+    if (i < 0 && (errno == EWOULDBLOCK || errno == EAGAIN || errno == EINTR))
+        return;
+
+    /* On any other errors or on EOF, the socket is unrecoverable. */
+    if (i <= 0) {
         remote_shutdown(rr);
         return;
-    } else if (i == 0) {
-        remote_del_flags(rr, FLAGS_READ);
     }
 
     /* If we have a partial read or just the header, try again. */
-- 
2.9.3

