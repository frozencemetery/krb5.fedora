From 3001200ba4598aeb14511353a72dc746034280b1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Fabiano=20Fid=C3=AAncio?= <fidencio@redhat.com>
Date: Wed, 28 Mar 2018 18:27:06 +0200
Subject: [PATCH] Continue after KRB5_CC_END in KCM cache iteration

The KCM server returns KRB5_CC_END in response to a GET_CACHE_BY_UUID
request to indicate that the specified ccache uuid no longer exists.
In krb5_ptcursor_next(), ignore this error and continue the iteration,
as the Heimdal KCM client code does.

In addition to addressing the case where a third party deletes a cache
between the GET_CACHE_UUID_LIST request and when we reach that uuid in
the iteration, this change also fixes a bug in kdestroy -A where the
caller deletes the primary cache and we later request it by uuid when
iterating over the list.

[ghudson@mit.edu: rewrote commit message; edited comment]

ticket: 8658 (new)
tags: pullup
target_version: 1.16-next
target_version: 1.15-next

(cherry picked from commit 49087f5e6309f298f8898c35af6f4ade418ced60)
---
 src/lib/krb5/ccache/cc_kcm.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/lib/krb5/ccache/cc_kcm.c b/src/lib/krb5/ccache/cc_kcm.c
index b621ed33b..0d38b1839 100644
--- a/src/lib/krb5/ccache/cc_kcm.c
+++ b/src/lib/krb5/ccache/cc_kcm.c
@@ -966,6 +966,9 @@ kcm_ptcursor_next(krb5_context context, krb5_cc_ptcursor cursor,
         kcmreq_init(&req, KCM_OP_GET_CACHE_BY_UUID, NULL);
         k5_buf_add_len(&req.reqbuf, id, KCM_UUID_LEN);
         ret = kcmio_call(context, data->io, &req);
+        /* Continue if the cache has been deleted. */
+        if (ret == KRB5_CC_END)
+            continue;
         if (ret)
             goto cleanup;
         ret = kcmreq_get_name(&req, &name);
